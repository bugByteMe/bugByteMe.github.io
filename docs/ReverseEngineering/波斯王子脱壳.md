if relocation table num = 00:00, must be compressed
qv F5可以跳转到指定位置
看到retf

qv F7可以搜索

按Ctrl+k抢夺键盘控制权

es ds 初始值为PSP段地址
es+10h得到首段段地址

add ax, [000c] （1e13）为老的exe的长度/10h
复制shellcode到24A1：0后面，为了留出解压缩的空间
std 方向反向

repz src: 23D1:D96 dst: 24A1:D96
（cs:0 - cs:D96） to (24A1:0 - 24A1:D96)

retf跳转到24A1：38，在新段中运行

目标段地址24A1 = 首段 + 1E13h = 68E + 1E13 = 24A1

shell code cs - 首段段址 = 23B1 - 68E = 1D23

解压缩出口24A1：009C 或 \[101]（错误处理分支）

9C开始重定位，es为真实段地址，di为真实偏移地址

修改shellcode让它自己生成标准重定位表，考虑放在ss:0那里，如果远跳需要5字节，空间不够，要把257b：0转化成24A1：DA0，（与当前cs在同一段内）
a cs:db, call da0
u cs:da0观察某地址的代码

需要保存计数器和buff的指针，可以用cs:da0前面的空间操作，因为shellcode的长度不到da0（前面能看到时D97），原因是这个段要取整到10h，所以造成了这个空洞
e cs:d97 00 00（计数器） 00 00 00 80,让buffer在8000：0

修改24A1:00BD为call指令，call自己的函数

u cs:da0
a cs:da0
注意用到的寄存器要做保护
```asm
push ax
push bx
push di
push es
mov ax, es ;此时es为要重定位的真实段地址
sub ax, bx ;delta段地址
les bx, cs:[d99] ;取出32位远指针，高位放在es里面了
mov es:[bx], di
mov es:[bx+2], ax
add word ptr cs:[d99], 4 ;更新buffer地址
inc word ptr cs:[d97] ;更新计数器
pop es
pop di
pop bx
pop ax
ret
```
dump 重定位表\[8000:0 - 8000:1894)
`writemem "xxx" 0x80000 0x1894`
dump exe
首段地址68E，shellcode段地址为终点即可（24A1）
(24A1 - 68e)\*0x10h
bpr（bprange） addr1 addr2 w检测某块内存有没有被写入
`writemem "xxx" 0x68E0 0x1E130`
继续跟踪，获得老exe的cs:ip ss:sp
凡是加上ax（首段地址的）就是段地址，另外的就是偏移地址了
exit rd结束调试，并恢复中断向量

选择老exe前1eh字节，保存下来作为文件头（1eh后面就是重定位表了）
shift F5插入新重定位表，offset 0 length 1894h
填入0E个00，使其为10h整数倍
alt F9保存
修正文件头长度信息

用010editor接着插入exe内容
Edit->insert File
修复文件长度（扇区数），重定位项个数625，(delta_ss=2821, delta_sp=0010), delta cs ip

**IDA 分析**
	sprintf段地址seg010，要计算和seg000的距离。
	`View->Open subviews->Segments` 列出所有段的信息，关注base信息.
	发现是`26AC-1000 = 16AC` 
	`sprintf = 首段地址+16AC:0B26`
	断住sprintf后，d ss:sp 查看堆栈内容 
	`xx xx xx xx（返回地址）
	`xx xx （buffer地址） xx xx （格式串地址）`
	`xx page xx line xx word`
	


bl查看所有断点

重定位表被修改：
Δ段地址=等于0 - 1000h(10000) - 2000h(20000)手动增加

第一轮循环重定位的段地址一直是68E（首段地址）

a cs:bd nop nop nop修改指令，发现4E7是重定向个数，段地址为0

第一张表24A1:12D - 24A1:AFC
第二张表24A1:AFD - 24A1:D7A
重定位表范围 \[24A1:12D ~ D7B\) 长度: D7B-12D = C4E

es = 1000h di = ffffh
`add word ptr es:[di], bx` 会尝试取1000:ffff和1000:0000 的byte，会死机

dump内存
范围：\[68E:0 - 24A1:0\)（shell code 起始地址-1）
`writemem "xxx" 0x68e0 1E130h`

dump重定位表

找最终ss:sp 和 cs:ip的赋值
sp=1000h
delta_ss=2128h
ip=02BCh
delta_cs=16ACh


